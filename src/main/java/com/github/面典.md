> [返回目录](https://github.com/Crab2died/jdepth)

#														面典

## 一. JAVA基础
### 1. 9种基本数据类型及其封装类,所占大小
  |   类型   |     包装类     | 大小(字节) |
  |:--------:|:--------------:|:----------:|
  |   byte   |    Byte        |      1     |
  |   char   |    Character   |      2     |
  |   short  |    Short       |      2     |
  |   int    |    Integer     |      4     |
  |   float  |    Float       |      4     |
  |   double |    Double      |      8     |
  |   long   |    Long        |      8     |
  |   boolean|    Boolean     |      -     |
  |   void   |    Void        |      -     | 

### 2. Object类方法
   - getClass() 获取类对象Class (native)
   - hashCode() 获取hashCode值(native)
   - equals(Object) 判断是否同一对象
   - clone() 对象克隆(native)
   - wait() 
   - wait(timeout)
   - wait(timeout, nanos)
   - notify()
   - notifyAll()
   - toString()
   - finalize() (protected)

### 3. equals 、hashCode、== 比较
   - equals是Object类方法，内部实现的是判断对象是否相等(即 ==)。
   - hashCode是Object的native方法，返回的是类似表示对象地址的整数。
   - ==是判断2个对象是否相同。
   - 如果2个对象相同则hashCode一定相等，若2个对象不同hashCode不一定相等。
   - 一般地重写了equals方法建议也要重写hashCode方法。
   
### 4. 面向对象的特性与含义
   - **封装**  是指将某事物的属性和行为包装到对象中，这个对象只对外公布需要公开的属性和行为，而这个公布也是可以有选择性的公布
     给其它对象，private、protected、public三种修饰符或不用(即默认default)对外部对象访问该对象的属性和行为进行限制。
   - **继承**  是子对象可以继承父对象的属性和行为，亦即父对象拥有的属性和行为，其子对象也就拥有了这些属性和行为。
   - **多态**  是指父对象中的同一个行为能在其多个子对象中有不同的表现。也就是说子对象可以使用重写父对象中的行为,使其拥有不同于
     父对象和其它子对象的表现,这就是overriding(重写)。实现多态的技术称为：动态绑定(dynamic binding)，是指在执行期间判
     断所引用对象的实际类型，根据其实际的类型调用其相应的方法。
	 
### 5. Override与Overload
   - Override是重写:方法名称、参数个数，类型，顺序，返回值类型都是必须和父类方法一致的。它的关系是父子关系。
   - Overload是重载:方法名称不变，方法参数个数、类型、顺序至少一个不同。它的关系是同一个类，同一个方法名。

### 6. wait与sleep
   - wait是Object类的方法；而sleep是Thread类的静态方法。
   - 当线程执行到wait方法时，他就会进入到该对象相关的等待池中，同时释放对象的机锁，其他线程可访问，直到超时或该对象调用notify
     或notifyAll；而当线程执行sleep方法时，线程进入阻塞状态，让出CPU资源，但在Synchronized同步块中不能释放对象的锁。
   - wait方法必须放在synchronized代码块中，否则会在时抛出`java.lang.IllegalMonitorStateException`异常。
   - wait和sleep都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException(但不建议使用该方法)。

### 7. java并发
   - [java并发编程](https://github.com/Crab2died/jdepth/blob/master/src/main/java/com/github/jvm/concurrent/JVM%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.md)   

### 8. interface与abstract类
   - 抽象类是包含有抽象方法的类(也可以拥有成员变量和普通成员方法)，抽象方法是只有方法声明没有具体实现的方法，所以抽象类不能实例化，是为了继承而存的，
     抽象类与普通类有3点区别：
	 - 1.抽象方法必须是public或protected，缺损情况下默认为public;
	 - 2.抽象类不能被实例化；
	 - 3.如果一个类继承了抽象类，则子类必须实现父类的抽象方法，若没有实现父类抽象方法，则子类也必须定义为抽象类。  
   - 接口是泛指供别人调用的方法或函数，接口中可以有变量和方法，变量被隐式地指定为public static final，方法被隐式地指定为public abstract,接口中的
     方法不能有具体的实现(JDK8之后接口可以有default方法)。
   - 接口与抽象类比较: 
     - 1.语法层面上:
	   - 1).抽象类可以提供成员方法的实现细节而接口中只能存在public abstract方法
	   - 2).抽象类中的成员变量可以是各种类型，而接口中的成员变量只能是public static final类型
	   - 3).接口中不能存在静态代码块和静态方法，而抽象类中可以
	   - 4).一个类只能继承一个抽象类而可以实现多个接口
     - 2.设计层面上: 
	   - 1).抽象类是对一种事物对象的抽象，而接口是对事物行为的抽象，抽象类是对整个类整体的抽象，包括属性、行为，而接口是对类的局部(行为)的抽象。继承抽
         象类是"是不是"的关系，实现接口是"有没有"的关系。
       - 2).设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计，而接口是一种行为规范，它是一种辐射式设计   
   
## JVM
### 1. 内存模型
   - **堆内存(Heap)** 是线程间共享内存，主要存放java的对象及数组
   - **栈内存(Stack)** 是线程间不共享的，主要存放基本数据类型和对象及数组的引用等   
   - **方法区(Method Area)** 是存储已被虚拟机加载的类信息、 常量、 静态变量、 即时编译器编译后的代码等数据
   - **本地方法栈(Native Method Stack)** 为虚拟机调用本地Native方法提供服务,有的虚拟机与虚拟机栈合二为一
   - **程序计数器(Program Counter Register)** 是当前虚拟机执行指令的地址，当执行到Native方法时其值为空(Undefined)
   - **运行时常量池(Runtime Constant Pool)** 用于存放编译期生成的各种字面量和符号引用,这部分内容将在类加载后进入方法区的运行时常量池中存放
   - **直接内存(Direct Memory)** NIO的DirectByteBuffer对象使用直接内存,这样能在一些场景中显著提高性能,因为避免了在Java堆和Native堆中来回复制数据

### 2. GC的2种判定方法
   - **引用计数**: 实现简单、高效，但会出现循环引用的时候对象将无法得到回收
   - **引用链**：即可达性分析，以GC Roots为根节点开始向下搜索，所走的路径叫做引用链(Reference Chain)，当一个对象到GC Roots对象没有任何引用链时说明该对象不可用，
     可作为GC Roots的对象：
     - 1.虚拟机栈（栈帧中的本地变量表）中引用的对象。
     - 2.方法区中的类静态属性引用的对象或者常量引用的对象。
     - 3.本地方法栈中JNI（就是native方法）引用的对象。	 

### 3. java自动内存管理
   - [java自动内存管理](https://github.com/Crab2died/jdepth/blob/master/src/main/java/com/github/jvm/gc/GC.md)   
	 
## 其他
### 1. OSI网络模型
  | 层级 |  名称     |                            描述                                     |
  |:---:|:-----------|:--------------------------------------------------------------------|
  |  1  | 应用层     |指网络操作系统和具体的应用程序，对应WWW服务器、FTP服务器等应用软件   |
  |  2  | 表示层     |数据语法的转换、数据的传送等                                         |
  |  3  | 会话层     |建立起两端之间的会话关系，并负责数据的传送                           |
  |  4  | 传输层     |负责错误的检查与修复，以确保传送的质量，是TCP/UDP工作的地方。（报文）|
  |  5  | 网络层     |提供了编址方案,IP协议工作的地方(数据包）                             |
  |  6  | 数据链路层 |将由物理层传来的未经处理的位数据包装成数据帧                         |
  |  7  | 物理层     |对应网线、网卡、接口等物理设备(位)                                   |

### 2. TCP/IP协议
   - 应用层
   - 传输层
   - 网络层
   - 链路层

### 3. IP分类
   - A类地址（1.0.0.0-126.255.255.255）用于最大型的网络，该网络的节点数可达16,777,216个。
   - B类地址（128.0.0.0-191.255.255.255）用于中型网络，节点数可达65,536个。
   - C类地址（192.0.0.0-223.255.255.255）用于256个节点以下的小型网络的单点网络通信。
   - D类地址（224.0.0.0-239.255.255.255）并不反映网络的大小，只是用于组播，用来指定所分配的接收组播的节点组，这个节点组由组播订
     阅成员组成。D类地址的范围为
   - E类（240.0.0.0-255.255.255.254）地址用于试验。   
   
### 4. TCP与UDP
   - TCP、UDP都是传输层协议
   - TCP(Transmission Control Protocol, 传输控制协议) 是面向连接的协议(即在收发数据前必须和对方建立可靠连接)，TCP建立连接要3次
     握手，TCP断开连接需要4次挥手，保证了数据通信的可靠性；TCP包头最小长度为20个字节数。
   - UDP(User Data Protocol, 用户数据报协议) 是一个非连接的协议(即传输数据之前源端和终端不建立连接)，只是简单的把应用程序的数据
     尽快地扔到网络上，因此UDP传输速度只受应用程序生成数据速度、计算机的能力和传输带宽的限制，接收端，UDP把每个消息段放入队列中
	 应用程序读取使用；UDP可以一台服务器同时向多台客户机传输相同数据；UDP消息头很短只有8个字节；UDP尽可能快的发送数据，但不保证
	 数据的可靠性(丢包，顺序等)；UDP是面向报文的，发送方的报文只是添加首部后就向下交付给IP层，既不拆分也不合并，这些需要接收端
	 应用程序自己实现。

### 5. 死锁的必要条件
   - **互斥条件**：资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源
     被另一进程占有时，则申请者等待直到资源被占有者释放。
   - **不可剥夺条件**：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。
   - **请求和保持条件**：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。
   - **循环等待条件**：在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有
     的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所深情地资源。	 

### 6. MySQL索引(5.5版本之前默认MyISAM引擎，5.5之后默认InnoDB)
   - MyISAM使用B-Tree实现主键索引、唯一索引和非主键索引。
   - InnoDB中非主键索引使用的是B-Tree数据结构，而主键索引使用的是B+Tree。	 

### 7. 进程与线程
   - 进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元
   - 同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程。
   - 进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进
     程中的其他线程的结束   
   - 线程是轻量级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的
   - 线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源
   - 线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标
     示一个进程或一个线程的标志

### 8. IPC通信方式
   - **管道(Pipe)**：匿名管道（pipe亲缘关系的进程通信）、命名管道（mkfifo/mknod）
   - **消息队列**：是基于消息的、用无亲缘关系的进程间通信，主要函数：msgget、msgsend、msgrecv、msgctl
   - **信号量**：相当于一把互斥锁，通过p、v操作，主要函数：semget、semop、semctl
   - **共享内存**：是进程间通信速度最快的，所以用经常是集合信号量或互斥锁来实现同步，shmget、shmat、shmdt、shmctl  

### 9. 虚拟内存
   - 是将进程部分装入内存中，从而能实现一个很大的程序能在一个比它小的内存中运行，它的主要实现是靠程序的换进换出来实现的，因为内存
     中0-3G是用户使用，3-4G才是内存使用，通过映射来实现来进行逻辑地址到物理地址的映射

### 10. 设计原则
   - 依赖倒置原则－Dependency Inversion Principle (DIP) 
   - 里氏替换原则－Liskov Substitution Principle (LSP) 
   - 接口分隔原则－Interface Segregation Principle (ISP) 
   - 单一职责原则－Single Responsibility Principle (SRP) 
   - 开闭原则－The Open-Closed Principle (OCP)
	 
> [返回目录](https://github.com/Crab2died/jdepth)

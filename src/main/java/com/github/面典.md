> [返回目录](https://github.com/Crab2died/jdepth)

#														面典

## 一. JAVA基础
### 1. 9种基本数据类型及其封装类,所占大小
  |   类型   |     包装类     | 大小(字节) |
  |:--------:|:--------------:|:----------:|
  |   byte   |    Byte        |      1     |
  |   char   |    Character   |      2     |
  |   short  |    Short       |      2     |
  |   int    |    Integer     |      4     |
  |   float  |    Float       |      4     |
  |   double |    Double      |      8     |
  |   long   |    Long        |      8     |
  |   boolean|    Boolean     |      -     |
  |   void   |    Void        |      -     | 

### 2. Object类方法
   - getClass()
   - hashCode()
   - equals(Object)
   - wait()
   - wait(timeout)
   - wait(timeout, nanos)
   - notify()
   - notifyAll()
   - toString()
   - finalize()

### 3. equals 、hashCode、== 比较
   - equals是Object类方法，内部实现的是判断对象是否相等(即 ==)。
   - hashCode是Object的native方法，返回的是类似表示对象地址的整数。
   - ==是判断2个对象是否相同。
   - 如果2个对象相同则hashCode一定相等，若2个对象不同hashCode不一定相等。
   - 一般地重写了equals方法建议也要重写hashCode方法。
   
### 4. 面向对象的特性与含义
   - 封装  是指将某事物的属性和行为包装到对象中，这个对象只对外公布需要公开的属性和行为，而这个公布也是可以有选择性的公布
     给其它对象，private、protected、public三种修饰符或不用（即默认default）对外部对象访问该对象的属性和行为进行限制。
   - 继承  是子对象可以继承父对象的属性和行为，亦即父对象拥有的属性和行为，其子对象也就拥有了这些属性和行为。
   - 多态  是指父对象中的同一个行为能在其多个子对象中有不同的表现。也就是说子对象可以使用重写父对象中的行为,使其拥有不同于
     父对象和其它子对象的表现,这就是overriding(重写)。实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判
     断所引用对象的实际类型，根据其实际的类型调用其相应的方法。
	 
### 5. Override与Overload
   - Override是重写:方法名称、参数个数，类型，顺序，返回值类型都是必须和父类方法一致的。它的关系是父子关系。
   - Overload是重载:方法名称不变，方法参数个数、类型、顺序至少一个不同。它的关系是同一个类，同一个方法名。

### 6. wait与sleep
   - wait是Object类的方法；而sleep是Thread类的静态方法。
   - 当线程执行到wait方法时，他就会进入到该对象相关的等待池中，同时释放对象的机锁，其他线程可访问，直到超时或该对象调用notify
     或notifyAll；而当线程执行sleep方法时，线程进入阻塞状态，让出CPU资源，但在Synchronized同步块中不能释放对象的锁。
   - wait方法必须放在synchronized代码块中，否则会在时抛出`java.lang.IllegalMonitorStateException`异常。
   - wait和sleep都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException(但不建议使用该方法)。

### 7. java并发
   - [java并发编程](https://github.com/Crab2died/jdepth/blob/master/src/main/java/com/github/jvm/concurrent/JVM%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.md)   
   
## JVM
### 1. 内存模型
   - 堆内存(Heap) 是线程间共享内存，主要存放java的对象及数组
   - 栈内存(Stack) 是线程间不共享的，主要存放基本数据类型和对象及数组的引用等   
   - 方法区(Method Area) 是存储已被虚拟机加载的类信息、 常量、 静态变量、 即时编译器编译后的代码等数据
   - 本地方法栈(Native Method Stack) 为虚拟机调用本地Native方法提供服务,有的虚拟机与虚拟机栈合二为一
   - 程序计数器(Program Counter Register) 是当前虚拟机执行指令的地址，当执行到Native方法时其值为空(Undefined)
   - 运行时常量池(Runtime Constant Pool) 用于存放编译期生成的各种字面量和符号引用,这部分内容将在类加载后进入方法区的运行时常量池中存放
   - 直接内存(Direct Memory) NIO的DirectByteBuffer对象使用直接内存,这样能在一些场景中显著提高性能,因为避免了在Java堆和Native堆中来回复制数据

### 2. GC的2种判定方法
   - 引用计数: 实现简单、高效，但会出现循环引用的时候对象将无法得到回收
   - 引用链：即可达性分析，以GC Roots为根节点开始向下搜索，所走的路径叫做引用链(Reference Chain)，当一个对象到GC Roots对象没有任何引用链时说明该对象不可用，
     可作为GC Roots的对象：
     - 1.虚拟机栈（栈帧中的本地变量表）中引用的对象。
     - 2.方法区中的类静态属性引用的对象或者常量引用的对象。
     - 3.本地方法栈中JNI（就是native方法）引用的对象。	 
   
## 其他
### 1. OSI网络模型
  | 层级 |  名称     |                            描述                                     |
  |:---:|:-----------|:--------------------------------------------------------------------|
  |  1  | 应用层     |指网络操作系统和具体的应用程序，对应WWW服务器、FTP服务器等应用软件   |
  |  2  | 表示层     |数据语法的转换、数据的传送等                                         |
  |  3  | 会话层     |建立起两端之间的会话关系，并负责数据的传送                           |
  |  4  | 传输层     |负责错误的检查与修复，以确保传送的质量，是TCP/UDP工作的地方。（报文）|
  |  5  | 网络层     |提供了编址方案,IP协议工作的地方(数据包）                             |
  |  6  | 数据链路层 |将由物理层传来的未经处理的位数据包装成数据帧                         |
  |  7  | 物理层     |对应网线、网卡、接口等物理设备(位)                                   |

### 2. TCP/IP协议
   - 应用层
   - 传输层
   - 网络层
   - 链路层

### 3. IP分类
   - A类地址（1.0.0.0-126.255.255.255）用于最大型的网络，该网络的节点数可达16,777,216个。
   - B类地址（128.0.0.0-191.255.255.255）用于中型网络，节点数可达65,536个。
   - C类地址（192.0.0.0-223.255.255.255）用于256个节点以下的小型网络的单点网络通信。
   - D类地址（224.0.0.0-239.255.255.255）并不反映网络的大小，只是用于组播，用来指定所分配的接收组播的节点组，这个节点组由组播订
     阅成员组成。D类地址的范围为
   - E类（240.0.0.0-255.255.255.254）地址用于试验。   
   
### 4. TCP与UDP
   - TCP、UDP都是传输层协议
   - TCP(Transmission Control Protocol, 传输控制协议) 是面向连接的协议(即在收发数据前必须和对方建立可靠连接)，TCP建立连接要3次
     握手，TCP断开连接需要4次挥手，保证了数据通信的可靠性；TCP包头最小长度为20个字节数。
   - UDP(User Data Protocol, 用户数据报协议) 是一个非连接的协议(即传输数据之前源端和终端不建立连接)，只是简单的把应用程序的数据
     尽快地扔到网络上，因此UDP传输速度只受应用程序生成数据速度、计算机的能力和传输带宽的限制，接收端，UDP把每个消息段放入队列中
	 应用程序读取使用；UDP可以一台服务器同时向多台客户机传输相同数据；UDP消息头很短只有8个字节；UDP尽可能快的发送数据，但不保证
	 数据的可靠性(丢包，顺序等)；UDP是面向报文的，发送方的报文只是添加首部后就向下交付给IP层，既不拆分也不合并，这些需要接收端
	 应用程序自己实现。

### 5. 死锁的必要条件
   - 互斥条件：资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源
     被另一进程占有时，则申请者等待直到资源被占有者释放。
   - 不可剥夺条件：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。
   - 请求和保持条件：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。
   - 循环等待条件：在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有
     的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所深情地资源。	 

### 6. MySQL索引(5.5版本之前默认MyISAM引擎，5.5之后默认InnoDB)
   - MyISAM使用B-Tree实现主键索引、唯一索引和非主键索引。
   - InnoDB中非主键索引使用的是B-Tree数据结构，而主键索引使用的是B+Tree。	 
	 
> [返回目录](https://github.com/Crab2died/jdepth)
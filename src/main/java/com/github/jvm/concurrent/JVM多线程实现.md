> [返回目录](https://github.com/Crab2died/jdepth)

#                                               JVM多线程实现
----
## 1. JAVA与线程
### 1.1 线程的实现
   1. 实现方式:使用内核线程实现、 使用用户线程实现和使用用户线程加轻量级进程混合实现.
   2.
   
### 1.2 Java线程调度
   1. 线程调度是指系统为线程分配处理器使用权的过程,主要调度方式有两种,分别是协同式线程调度(Cooperative Threads-Scheduling)
      和抢占式线程调度(Preemptive ThreadsScheduling)
   2. 协同式线程调度:线程的执行时间由线程本身来控制,线程把自己的工作执行完了之后,要主动通知系统切换到另外一个线程上;
      优点是实现简单,缺点是线程执行时间不可控制,容易线程阻塞
   3. 每个线程将由系统来分配执行时间,线程的切换不由线程本身来决定(在Java中,Thread.yield()可以让出执行时间,但是要获取执行时
      间的话,线程本身是没有什么办法的);优点是线程的执行时间是系统可控的,也不会有一个线程导致整个进程阻塞的问题.
   4. JAVA线程有10个优先级(Thread.MIN_PRIORITY至Thread.MAX_PRIORITY)
   
### 1.3 线程转换状态
   1. JAVA线程定义了5个状态:  
      * 新建(New):创建后尚未启动的线程处于这种状态.
      * 运行(Runable):Runable包括了操作系统线程状态中的Running和Ready,也就是处于此状态的线程有可能正在执行,也有可能正在
        等待着CPU为它分配执行时间.
      * 无限期等待(Waiting):处于这种状态的线程不会被分配CPU执行时间,它们要等待被  
            其他线程显式地唤醒. 以下方法会让线程陷入无限期的等待状态:  
            ●没有设置Timeout参数的Object.wait()方法.  
            ●没有设置Timeout参数的Thread.join()方法.  
            ●LockSupport.park()方法.  
      * 限期等待(Timed Waiting):处于这种状态的线程也不会被分配CPU执行时间,不过无须等待被其他线程显式地唤醒,在一定时间之后
        它们会由系统自动唤醒. 以下方法会让线程进入限期等待状态:  
            ●Thread.sleep()方法.  
            ●设置了Timeout参数的Object.wait()方法.  
            ●设置了Timeout参数的Thread.join()方法.  
            ●LockSupport.parkNanos()方法.  
            ●LockSupport.parkUntil()方法  
      * 结束(Terminated):已终止线程的线程状态,线程已经结束执行.
   2. 线程状态转换关系图  
      ![线程状态转换关系](https://raw.githubusercontent.com/Crab2died/jdepth/master/src/main/java/com/github/jvm/concurrent/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB.png)
   
## 2. 线程安全与锁优化
### 2.1 JAVA中的线程安全
   1. 共享数据分类
      * 不可变(Immutable):不可变对象一定是线程安全的,典型的final
      * 绝对线程安全:
      * 相对线程安全: java大部分的线程安全都是相对线程安全的
      * 线程兼容:
      * 线程对立:
   2.
   
## 3. 锁介绍
### 3.1 自旋锁
   1. 自旋锁可以使线程在没有取得锁的时候，不被挂起，而转去执行一个空循环，（即所谓的自旋，就是自己执行空循环），若在若干个空循环后，线程
      如果可以获得锁，则继续执行。若线程依然不能获得锁，才会被挂起。使用自旋锁后，线程被挂起的几率相对减少，线程执行的连贯性相对加强。因
      此，对于那些锁竞争不是很激烈，锁占用时间很短的并发线程，具有一定的积极意义，但对于锁竞争激烈，单线程锁占用很长时间的并发程序，自旋
      锁在自旋等待后，往往毅然无法获得对应的锁，不仅仅白白浪费了CPU时间，最终还是免不了被挂起的操作 ，反而浪费了系统的资源。在JDK1.6中，
      Java虚拟机提供-XX:+UseSpinning参数来开启自旋锁，使用-XX:PreBlockSpin参数来设置自旋锁等待的次数。在JDK1.7开始，自旋锁的参数被
      取消，虚拟机不再支持由用户配置自旋锁，自旋锁总是会执行，自旋锁次数也由虚拟机自动调整。  
   2. 问题：  
      - 可能白占用CPU时间
      - 死锁问题，自己占用锁，还在等待锁释放
      
### 3.2 阻塞锁
   1. 让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间） 时，才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争，进
      入运行状态。JAVA中，能够进入\退出、阻塞状态或包含阻塞锁的方法有 ，synchronized 关键字（其中的重量锁），ReentrantLock，
      Object.wait()\notify() 

### 3.3 可重入锁
   1. 可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。    
      在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁

### 3.4 乐观锁和悲观锁
   1. 悲观锁: 每次拿数据都上锁，如行锁、表锁、读锁、写锁
   2. 乐观锁: 每次拿数据都不上锁，只是在修改前验证下数据在此期间有无更新，如版本号控制

### 3.5 轮询锁和定时锁
   1. 由tryLock实现，与无条件获取锁模式相比，它们具有更完善的错误恢复机制。可避免死锁的发生：  
      boolean tryLock()：仅在调用时锁为空闲状态才获取该锁。如果锁可用，则获取锁，并立即返回值 true。
      如果锁不可用，则此方法将立即返回值 false。
      boolean tryLock(long time, TimeUnit unit) throws InterruptedException：
      如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁。
      
### 3.6 显示锁和内置锁
   1. 显示锁用Lock来定义、内置锁用synchronized。
   
### 3.7 对象锁和类锁
   1. 对象锁是用于实例对象(可有多个实例对象)方法上的
   2. 类锁是作用于对象的静态方法和Class(一个类只有一个Class对象)对象上的

### 3.8 互斥锁
   1. 互斥锁, 指的是一次最多只能有一个线程持有的锁。如Java的Lock
   
### 3.9 锁粗化
   1. 将多个连续的锁操作合并成一个整体的锁

### 3.10 锁消除
   1. 通过逃逸分析，能证明堆上数据不会逃逸出当前线程，则认为是线程安全的，不必要加锁操作
  
     
> [返回目录](https://github.com/Crab2died/jdepth)
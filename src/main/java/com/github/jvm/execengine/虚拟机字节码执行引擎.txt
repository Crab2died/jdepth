
                                                虚拟机字节码执行引擎
1   运行时栈帧
1-1 栈帧(Stack Frame)
    1)  用于支持虚拟机进行方法调用和方法执行的数据结构
    2)  存储了方法的局部变量表、 操作数栈、 动态连接和方法返回地址等信息
    3)  每一个栈帧都包括了局部变量表、 操作数栈、 动态连接、 方法返回地址和一些额外的附加信息
    4)  在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中
    5)  执行引擎运行的所有字节码指令都只针对当前栈帧进行操作
1-2 局部变量表(Local Variable Table)
    1)  是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量
    2)  编译期就在方法的code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量
    3)  局部变量表的容量以变量槽（Variable Slot，下称Slot）为最小单位
1-3 操作数栈(Operand Stack)
    1)  也称作操作栈，他是后入先出(LIFO)栈
    2)  操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中
    3)  操作数栈刚开始时空的，在方法执行过程中会有各种字节码指令往操作数栈内写入或读出(入栈/出栈)
1-4 动态链接(Dynamic Linking)
    1)  每个栈帧都包含一个指向运行时常量池[1]中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接
1-5 方法返回地址
    1)  方法完成退出方式：一种是正常完成退出,另一种是异常完成退出
    2)  方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，
        把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。
1-6 附加信息
    例如与调试相关的信息，在实际开发中，一般会把动态连接、 方法返回地址与其他附加信息全部归为一类，称为栈帧信息。

2   方法调用(确定调用方法版本问题)
2-1 解析(将方法的符号应用转换为直接引用)
    1)  方法调用目标在程序代码写好、 编译器进行编译时就必须确定下来
    2)  编译期可知，运行期不可变 - 主要包括静态方法和私有方法，都适合在类加载阶段进行解析
    3)  静态方法、 私有方法、 实例构造器、 父类方法4类，它们在类加载的时候就会把符号引用解析为该方法的直接引用, final方法也是
    4)  解析调用一定是个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，
        不会延迟到运行期再去完成
2-2 分派(多态特征的基本体现、重载与重写)
    - 1 静态分派(例:StaticDispatch.java、Overload.java)
        1)  所有依赖静态类型来定位方法执行版本的分派动作称为静态分派
        2)  静态分派的典型应用是方法重载
        3)  静态分派发生在编译阶段
    - 2 动态分派(例：DynamicDispatch.java)
        1)  动态分派的典型应用是方法重写
        2)  invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言中方法重写的本质。
            我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。
        3)  动态分派相当繁琐，虚拟机加入了优化方案：使用方法表、内联缓存基于“类型继承关系分析”(Class Hierarchy Analysis,CHA)
            技术的守护内联（Guarded Inlining）
    - 3 单分派 & 多分派
        1)  宗量:方法的接收者与方法的参数统称为方法的宗量
        2)  单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择
2-3 总结
    java 是一门静态多分派、动态单分派语言
2-4 动态语言(Dynamically Typed Language)支持
    1)  JDK1.7加入指令invokedynamic
    2)  动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期
    3)  动态语言特征:变量无类型而变量值才有类型

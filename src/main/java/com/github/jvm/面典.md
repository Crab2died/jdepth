> [返回目录](https://github.com/Crab2died/jdepth)

#														面典

## 一. JAVA基础
### 1. 9种基本数据类型及其封装类,所占大小
  |   类型   |     包装类     | 大小(字节) |
  |:--------:|:--------------:|:----------:|
  |   byte   |    Byte        |      1     |
  |   char   |    Character   |      2     |
  |   short  |    Short       |      2     |
  |   int    |    Integer     |      4     |
  |   float  |    Float       |      4     |
  |   double |    Double      |      8     |
  |   long   |    Long        |      8     |
  |   boolean|    Boolean     |      -     |
  |   void   |    Void        |      -     | 

### 2. Object类方法
   - getClass()
   - hashCode()
   - equals(Object)
   - wait()
   - wait(timeout)
   - wait(timeout, nanos)
   - notify()
   - notifyAll()
   - toString()
   - finalize()

### 3. equals 、hashCode、== 比较
   
### 4. 面向对象的特性与含义
   - 封装  是指将某事物的属性和行为包装到对象中，这个对象只对外公布需要公开的属性和行为，而这个公布也是可以有选择性的公布
     给其它对象，private、protected、public三种修饰符或不用（即默认default）对外部对象访问该对象的属性和行为进行限制。
   - 继承  是子对象可以继承父对象的属性和行为，亦即父对象拥有的属性和行为，其子对象也就拥有了这些属性和行为。
   - 多态  是指父对象中的同一个行为能在其多个子对象中有不同的表现。也就是说子对象可以使用重写父对象中的行为,使其拥有不同于
     父对象和其它子对象的表现,这就是overriding(重写)。实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判
     断所引用对象的实际类型，根据其实际的类型调用其相应的方法。
	 
### 5. Override与Overload
   - Override是重写:方法名称、参数个数，类型，顺序，返回值类型都是必须和父类方法一致的。它的关系是父子关系。
   - Overload是重载:方法名称不变，方法参数个数、类型、顺序至少一个不同。它的关系是同一个类，同一个方法名。

### 6. wait与sleep
   - wait是Object类的方法；而sleep是Thread类的静态方法。
   - 当线程执行到wait方法时，他就会进入到该对象相关的等待池中，同时释放对象的机锁，其他线程可访问，直到超时或该对象调用notify
     或notifyAll；而当线程执行sleep方法时，线程进入阻塞状态，让出CPU资源，但在Synchronized同步块中不能释放对象的锁。
   - wait方法必须放在synchronized代码块中，否则会在时抛出`java.lang.IllegalMonitorStateException`异常。
   - wait和sleep都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException(但不建议使用该方法)。

## JVM
### 1. 内存模型
   

## 其他
### 1. OSI网络模型
  | 层级 |  名称     |                            描述                                     |
  |:---:|:-----------|:--------------------------------------------------------------------|
  |  1  | 应用层     |指网络操作系统和具体的应用程序，对应WWW服务器、FTP服务器等应用软件   |
  |  2  | 表示层     |数据语法的转换、数据的传送等                                         |
  |  3  | 会话层     |建立起两端之间的会话关系，并负责数据的传送                           |
  |  4  | 传输层     |负责错误的检查与修复，以确保传送的质量，是TCP/UDP工作的地方。（报文）|
  |  5  | 网络层     |提供了编址方案,IP协议工作的地方(数据包）                             |
  |  6  | 数据链路层 |将由物理层传来的未经处理的位数据包装成数据帧                         |
  |  7  | 物理层     |对应网线、网卡、接口等物理设备(位)                                   |

### 2. TCP/IP协议
   - 应用层
   - 传输层
   - 网络层
   - 链路层

### 3. IP分类
   - A类地址（1.0.0.0-126.255.255.255）用于最大型的网络，该网络的节点数可达16,777,216个。
   - B类地址（128.0.0.0-191.255.255.255）用于中型网络，节点数可达65,536个。
   - C类地址（192.0.0.0-223.255.255.255）用于256个节点以下的小型网络的单点网络通信。
   - D类地址（224.0.0.0-239.255.255.255）并不反映网络的大小，只是用于组播，用来指定所分配的接收组播的节点组，这个节点组由组播订
     阅成员组成。D类地址的范围为
   - E类（240.0.0.0-255.255.255.254）地址用于试验。   
   
### 4. TCP与UDP
   - TCP、UDP都是传输层协议
   - TCP(Transmission Control Protocol, 传输控制协议) 是面向连接的协议(即在收发数据前必须和对方建立可靠连接)，TCP建立连接要3次
     握手，TCP断开连接需要4次挥手，保证了数据通信的可靠性；TCP包头最小长度为20个字节数。
   - UDP(User Data Protocol, 用户数据报协议) 是一个非连接的协议(即传输数据之前源端和终端不建立连接)，只是简单的把应用程序的数据
     尽快地扔到网络上，因此UDP传输速度只受应用程序生成数据速度、计算机的能力和传输带宽的限制，接收端，UDP把每个消息段放入队列中
	 应用程序读取使用；UDP可以一台服务器同时向多台客户机传输相同数据；UDP消息头很短只有8个字节；UDP尽可能快的发送数据，但不保证
	 数据的可靠性(丢包，顺序等)；UDP是面向报文的，发送方的报文只是添加首部后就向下交付给IP层，既不拆分也不合并，这些需要接收端
	 应用程序自己实现。

### 5. 死锁的必要条件
   - 互斥条件：资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源
     被另一进程占有时，则申请者等待直到资源被占有者释放。
   - 不可剥夺条件：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。
   - 请求和保持条件：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。
   - 循环等待条件：在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有
     的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所深情地资源。	 

> [返回目录](https://github.com/Crab2died/jdepth)
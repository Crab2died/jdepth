#                                               Netty
----

## 一. Netty特点介绍
  -  一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持  
  -  使用更高效的socket底层，对epoll空轮询引起的cpu占用飙升在内部进行了处理，避免了直接使用NIO的陷阱，简化了NIO的处理方式。  
  -  采用多种decoder/encoder 支持，对TCP粘包/分包进行自动化处理  
  -  可使用接受/处理线程池，提高连接效率，对重连、心跳检测的简单支持  
  -  可配置IO线程数、TCP参数， TCP接收和发送缓冲区使用直接内存代替堆内存，通过内存池的方式循环利用ByteBuf   
  -  通过引用计数器及时申请释放不再引用的对象，降低了GC频率   
  -  使用单线程串行化的方式，高效的Reactor线程模型   
  -  大量使用了volatile、使用了CAS和原子类、线程安全类的使用、读写锁的使用  

## 二. Reactor模型(Netty线程模型)   
  - 1)事件驱动
  - 2)一个或多个并发输入源
  - 3)一个service handler和多个request handlers
### 线程模型
  - 1)单线程模型:一个线程处理所有的IO操作，即所有的多路复用、事件分发和处理都在一个Reactor线程上完成，对于高并发、大负载并不适用  
  - 2)多线程模型:有一个NIO线程(Accepter)只负责监听服务，接收客户端的TCP连接请求，NIO线程池负责网络IO的操作，包括消息读取、编码、
    解码和发送，对于高客户端连接量对于单线程处理Accepter会有压力   
  - 3)主从线程模型:Accepter线程绑定监听端口，接收客户端连接，将SocketChannel从住线程池的Reactor线程的多路复用器中移除，重新注
    册到从线程池上，用于处理IO读写操作。

## 三. 序列化
### 1.介绍
   1. 序列化(编码):序列化是将对象转换成二进制形式，用于数据传输，数据持久化
   2. 反序列化(解码):是将二进制字节数组转换成原始对象
   3. 影响序列化的因素:  
     -序列化后的码流大小(关系网络带宽的占用)  
     -序列化的性能消耗(CPU资源的占用)  
     -是否支持跨语言(异构系统的对接和开发语言切换)  
     
### 2.几种序列化协议
   - 1)XML，优点是人机可读性强，缺点是序列化数据只包含数据本身以及类的结构不包括类型和程序信息，只能序列化公共属性和字段，占用空间
     较大，占网络带宽，适用于配置信息的传输
   - 2)JSON,轻量级的序列化协议；优点是兼容性好，数据格式简单，易于读写，序列化后数据量较小，易扩展，兼容性强，协议简单，
     解析速度较快；缺点是数据描述性没XML强，不适用于ms级的场景，额外的空间消耗较大
   - 3)Fastjson,
   - 4)Thrift,优点是序列化后的体积小, 速度快、支持多种语言和丰富的数据类型、对于数据字段的增删具有较强的兼容性、支持二进制压缩编
     码；缺点是使用者较少，跨防火墙访问时不安全
   - 5)Hessian,轻量级，采用二进制协议的轻量级remoting onhttp工具，必须实现java.io.Serializable接口
   - 6)Marshalling,可以直接序列化java类，无须实java.io.Serializable接口
   - 7)Avro,Hadoop子项目，优点：支持丰富的数据类型、简单的动态语言结合功能、具有自我描述属性、提高了数据解析速度、快速可压缩的二
     进制数据形式、可以实现远程过程调用RPC、支持跨编程语言实现。缺点：对于习惯于静态类型语言的用户不直观。适用场景：在Hadoop中做
     Hive、Pig和MapReduce的持久化数据格式。
   - 8)Protobuf,将数据结构以.proto文件进行描述，通过代码生成工具可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性。优点：
     序列化后码流小，性能高、结构化数据存储格式（XML JSON等）、通过标识字段的顺序，可以实现协议的前向兼容、结构化的文档更容易管理
     和维护。缺点：需要依赖于工具生成代码、支持的语言相对较少，官方只支持Java 、C++ 、python。适用场景：对性能要求高的RPC调用、具
     有良好的跨防火墙的访问属性、适合应用层对象的持久化
   - 9)protostuff与kryo,基于Protobuf协议，不需要配置proto文件

## 四. 源码分析
### 1.ByteBuf和相关辅助类
  * ByteBuf主要功能类图  
  ![ByteBuf主要功能类图](https://raw.githubusercontent.com/Crab2died/jdepth/master/src/main/java/com/github/io/netty/ByteBuf%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%E7%B1%BB%E5%9E%8B%E5%9B%BE.png)

### 2. ByteBuf数据模型
  - 1)初始态模型
  ```
    +--------------------------------------------------------+
    |                      writable bytes                    |
    +--------------------------------------------------------+
    |                                                        |
    0=writerIndex=readerIndex                            M=capacity
  ```
  - 2)写入态模型
  ```
    +--------------------------------+-----------------------+
    |  readable bytes                |     writable bytes    |
    +--------------------------------+-----------------------+
    |                                |                       |
    0=readerIndex               N=writerIndex            M=capacity
  
  ```
  - 3)读取态模型
  ```
    +------------------+----------------+--------------------+
    |discardable bytes | readable bytes |    writable bytes  |
    +------------------+----------------+--------------------+
    |                  |                |                    |
    0        K(K<=N)=readerIndex   N=writerIndex         M=capacity
  
  ```
  
 ### 3. Channel
 
 
 ### 4. ChannelHandler
                                           JAVA内存模型
1.  java内存模型
1.1 java内存模型.png
1.2 内存间的交互操作
    -1. 定义操作
        * lock(锁定)：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
        * unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
        * read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
        * load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
        * use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到
          变量的值的字节码指令时将会执行这个操作。
        * assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个
          给变量赋值的字节码指令时执行这个操作。
        * store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
        * write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。
    -2. 约束条件
        1) read和load、store和write必须保证顺序操作，不能单独出现，但不需要连续操作，中间可隔有其他操作
        2) 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
        3) 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。
        4) 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，
           就是对一个变量实施use、 store操作之前，必须先执行过了assign和load操作。
        5) 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，
          只有执行相同次数的unlock操作，变量才会被解锁
        6) 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，
          需要重新执行load或assign操作初始化变量的值。
        7) 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。
        8) 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、 write操作）
    -3. volatile
          假定T表示一个线程，V和W分别表示两个volatile型变量，那么在进行read、 load、 use、 assign、store和write操作时
      需要满足如下规则：
          只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且，只有当线程T对变量V执行的后一个动作是use
      的时候，线程T才能对变量V执行load动作。 线程T对变量V的use动作可以认为是和线程T对变量V的load、 read动作相关联，必须连续一起出现
      （这条规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所做的修改后的值）。
          只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作
      是store的时候，线程T才能对变量V执行assign动作。 线程T对变量V的assign动作可以认为是和线程T对变量V的store、 write动作相关
      联，必须连续一起出现(这条规则要求在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改)
          假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或store动作，假定动作P是和动作F相应的对变量V
      的read或write动作；类似的，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作
      Q是和动作G相应的对变量W的read或write动作。 如果A先于B，那么P先于Q（这条规则要求volatile修饰的变量不会被指令重排序优化，保证代
      码的执行顺序与程序的顺序相同）。
    -4. long和double的非原子性协定
        读写操作可分为2次32位操作，所以一定不是原子操作
        注：现在商用虚拟机本身几乎都已经实现了原子操作，所以不用volatile修饰符
1.3 原子性、 可见性与有序性
    -1. Java内存模型是围绕着在并发过程中如何处理原子性、 可见性和有序性这3个特征来建立的
        1)  原子性(Atomicity)：由Java内存模型来直接保证的原子性变量操作包括read、 load、assign、 use、 store和write，
            我们大致可以认为基本数据类型的访问读写是具备原子性的（例外就是long和double的非原子性协定，读者只要知道这件事情就可以了，
            无须太过在意这些几乎不会发生的例外情况）。synchronized内也是原子性
        2)  可见性(Visibility):可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。每次使用前立即从主内存刷新保证了
            可见性，除了volatile外synchronized、final也能实现可见性
        3)  有序性(Ordering): 如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。
            前半句是指“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与
            主内存同步延迟”现象。volatile、synchronized保证了有序性。
1.4 先行发生原则
    -1. 定义：
        先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能
        被操作B观察到，“影响”包括修改了内存中共享变量的值、 发送了消息、 调用了方法等。
    -2. 规则:
        1)  程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，
            应该是控制流顺序而不是程序代码顺序，因为要考虑分支、 循环等结构。
        2)  管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。 这里必须强调的是同一个锁，
            而“后面”是指时间上的先后顺序。
        3)  volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”
            同样是指时间上的先后顺序。
        4)  线程启动规则（Thread Start Rule）：Thread对象的start（）方法先行发生于此线程的每一个动作。
        5)  线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）
            方法结束、 Thread.isAlive（）的返回值等手段检测到线程已经终止执行。
        6)  线程中断规则（Thread Interruption Rule）：对线程interrupt（）方法的调用先行发生于被中断线程的代码检测到中断事件的发生，
            可以通过Thread.interrupted（）方法检测到是否有中断发生。
        7)  对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize（）方法的开始。
        8)  传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。
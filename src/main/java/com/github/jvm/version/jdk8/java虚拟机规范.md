> [返回目录](https://github.com/Crab2died/jdepth)

#                                                       JAVA虚拟机规范
---
##  一. java虚拟机结构
### 1. java虚拟机数据类型
   - 1.1. 原始类型(primitive type, 原生类型或基本类型) 、引用类型(reference type),与之对应的为原始值(primitive value)
     和引用值(reference value)
   - 1.2. 原始类型与值
     - 1.2.1 数字类型(numeric type)
       - 1)整数类型
       - 2)浮点数类型(单精度浮点数与双精度浮点数) 
     - 1.2.2 boolean类型  
       虚拟机对他的支持很少，甚至没有提供boolean值专门的字节码指令，编译之后都是用int数据类型来代替(1 <=> true  0 <=> false)
     - 1.2.3 returnAddress类型  
       returnAddress类型会被虚拟机的jsr、ret与jsr_w指令使用，其值指向一条虚拟机指令操作码
   - 1.3. 引用类型与值    
     - 1.3.1 类类型(class type)，指向动态创建的类实例
     - 1.3.2 数组类型(array type)，指向数组实例,数组类型最外面那一维元素类型成为该数组类型的组件类型(component type)，组件类型
       也可以是数组，抽丝剥茧最终一定会得到不是数组的情况，这就是数组元素类型(element type),数组的元素类型必须是原生类型、类类型
       或者接口类型之一
     - 1.3.3 接口类型(interface type), 指向实现了某个接口的实例或数组实例
   - 1.4. 运行时数据区   
     Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些
     则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。  
     - 1.4.1 PC寄存器  
       java虚拟机支持多线程，每一条线程都有自己的PC(program counter)寄存器，任意时刻，一条线程只会执行一个方法代码，正在被执行的
       方法称之为该线程的当前方法(current method),若这个方法不是native的，那PC寄存器保存正在执行字节码指令的地址，若为native的
       那么PC寄存器的值为undefined；PC寄存器的容量至少要能保存一个returnAddress类型的数据或一个与平台相关的本地指针的值。
     - 1.4.2 java虚拟机栈
       每一条java线程都有自己私有的java虚拟机栈(Java Virtual Machine Stack),与线程同时创建用以存储栈帧(frames),作用是存储局部
       变量与一些过程结果，在方法调用与返回中也起作用。栈帧可以在堆中分配，java虚拟机栈的内存不需要保证是连续的。虚拟机规范允许java
       虚拟机栈被实现成固定大小或者根据计算动态扩展与收缩的，但应当提供调节初始容量的手段，对于动态扩展与收缩的应当提供调节最大、最小
       容量的手段。  
       Java 虚拟机栈可能发生如下异常情况：
       - 如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量时，Java 虚拟机将会抛出一个StackOverflowError 异常。
       - 如果Java虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成扩展，或者在建立新的线程时没有
         足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 OutOfMemoryError 异常。
   
   
   
   
> [返回目录](https://github.com/Crab2died/jdepth)